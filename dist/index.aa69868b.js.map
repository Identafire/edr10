{"mappings":"AAAA,aAAa;AAEb,SAAS;IACP,EAAE,YAAY,WAAW,CAAC;IAC1B,EAAE,YAAY,WAAW,CAAC;AAC5B;AAEA,QAAQ;AAER,kEAAkE;AAClE,SAAS,gBAAgB,CAAC,oBAAoB;IAC5C,4CAA4C;IAC5C,MAAM,aAAa;QAAC;QAAsB;QAAmB;QAAgB;QAAkB;KAAmB,EAAE,2DAA2D;IAE/K,0BAA0B;IAC1B,MAAM,WAAW,IAAI,qBAAqB,CAAC;QACzC,QAAQ,OAAO,CAAC,CAAA;YACd,IAAI,MAAM,cAAc,EAAE;gBACxB,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,MAAM,MAAM,CAAC,EAAE,CAAC,gCAAgC,CAAC;gBACzE,qCAAqC;gBACrC,MAAM,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC;YAE3B,6CAA6C;YAC7C,oCAAoC;YACtC,OACE,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,MAAM,MAAM,CAAC,EAAE,CAAC,sCAAsC,CAAC;QAInF;IACF,GAAG;QACD,WAAW;QACX,MAAM;QACN,YAAY;QACZ,WAAW,IAAI,sDAAsD;IACvE;IAEA,2DAA2D;IAC3D,SAAS,gBAAgB,GAAG;QAC1B,IAAI,OAAO,CAAC,CAAA;YACV,MAAM,UAAU,SAAS,cAAc,CAAC;YACxC,IAAI,SAAS;gBACX,SAAS,OAAO,CAAC;gBACjB,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,IAAI;YACpD,OACE,QAAQ,IAAI,CAAC,CAAC,iBAAiB,EAAE,GAAG,wBAAwB,CAAC;QAEjE;IACF;IAEA,kDAAkD;IAClD,gBAAgB;IAEhB,wDAAwD;IACxD,+DAA+D;IAE/D,+DAA+D;IAC/D,OAAO,qBAAqB,GAAG,SAAS,GAAG;QACzC,IAAI,MAAM,OAAO,CAAC,MAChB,gBAAgB;aACX,IAAI,OAAO,QAAQ,UACxB,gBAAgB;YAAC;SAAI,GAAG,6BAA6B;aAErD,QAAQ,KAAK,CAAC;IAElB;AACF","sources":["src/js/main.js"],"sourcesContent":["//open switch\n\nfunction clickToOpen() {\n  $('#mainNav').toggleClass('close');\n  $('#mainNav').toggleClass('open');\n}\n\n//arrows\n\n// Option 1: Using the Intersection Observer API (modern approach)\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Accept an array of element IDs to observe\n  const elementIds = ['arrowIncreaseDemand','arrowEmpowering', 'arrowDynamic', 'arrowContinuous','arrowByEducators']; // Default value - can be modified or passed as a parameter\n  \n  // Initialize the observer\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        console.log(`Element #${entry.target.id} is now visible in the viewport!`);\n        // Add your action here, for example:\n        entry.target.classList.add('slideLeft');\n        \n        // Optional: Stop observing once it's visible\n        // observer.unobserve(entry.target);\n      } else {\n        console.log(`Element #${entry.target.id} is no longer visible in the viewport.`);\n        // Optional: Handle when element leaves the viewport\n        // entry.target.classList.remove('visible');\n      }\n    });\n  }, {\n    // Options:\n    root: null, // Use the viewport as the reference\n    rootMargin: '0px', // No margin\n    threshold: 0.1 // Trigger when at least 10% of the element is visible\n  });\n\n  // Function to initialize observation for multiple elements\n  function observeElements(ids) {\n    ids.forEach(id => {\n      const element = document.getElementById(id);\n      if (element) {\n        observer.observe(element);\n        console.log(`Now observing element with ID: ${id}`);\n      } else {\n        console.warn(`Element with ID \"${id}\" not found on the page.`);\n      }\n    });\n  }\n\n  // Start observing elements with the specified IDs\n  observeElements(elementIds);\n  \n  // Example of how to add more elements to observe later:\n  // observeElements(['another-element', 'yet-another-element']);\n  \n  // Utility function to set up observation for a new list of IDs\n  window.observeScrollElements = function(ids) {\n    if (Array.isArray(ids)) {\n      observeElements(ids);\n    } else if (typeof ids === 'string') {\n      observeElements([ids]); // Convert single ID to array\n    } else {\n      console.error('observeScrollElements requires an array of IDs or a single ID string');\n    }\n  };\n});"],"names":[],"version":3,"file":"index.aa69868b.js.map","sourceRoot":"/__parcel_source_root/"}